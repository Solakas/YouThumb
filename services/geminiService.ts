import { GoogleGenAI, Modality, Chat, GenerateContentResponse } from "@google/genai";

const API_KEY = process.env.API_KEY;
if (!API_KEY) {
  throw new Error("API_KEY environment variable not set");
}

const ai = new GoogleGenAI({ apiKey: API_KEY });

// Helper to convert data URL to a Gemini Part object
const dataUrlToGenerativePart = (dataUrl: string) => {
  const [meta, base64Data] = dataUrl.split(',');
  const mimeType = meta.split(';')[0].split(':')[1];
  return {
    inlineData: {
      mimeType,
      data: base64Data,
    },
  };
};

export const geminiService = {
  editImage: async (imageDataUrl: string, prompt: string, maskDataUrl?: string, guideImageDataUrl?: string): Promise<string> => {
    try {
      const imagePart = dataUrlToGenerativePart(imageDataUrl);
      
      const parts: any[] = [imagePart];
      let finalPrompt = prompt;

      if (guideImageDataUrl) {
          const guideImagePart = dataUrlToGenerativePart(guideImageDataUrl);
          parts.push(guideImagePart);
          finalPrompt = `${prompt}. IMPORTANT: Please use the second image provided as a strong visual and stylistic reference for your edits. Match its colors, lighting, and overall aesthetic. Apply the edit described in the prompt to the first image.`;
      }

      if (maskDataUrl) {
        const maskPart = dataUrlToGenerativePart(maskDataUrl);
        parts.push(maskPart);
        finalPrompt = `${prompt}. IMPORTANT: Apply this change ONLY to the area marked in white on the provided mask image. The rest of the image must remain untouched.`;
      }
      
      parts.push({ text: finalPrompt });

      const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: { parts },
        config: {
          responseModalities: [Modality.IMAGE],
        },
      });

      // Check for prompt-level blocking
      if (response.promptFeedback?.blockReason) {
        throw new Error(`Your prompt was blocked for safety reasons (${response.promptFeedback.blockReason}). Please modify your prompt and try again.`);
      }

      const candidate = response.candidates?.[0];

      // Check for response-level filtering
      if (candidate?.finishReason === 'SAFETY') {
        throw new Error("The edited image was blocked for safety reasons. Please try a different edit.");
      }
      
      if (candidate?.content?.parts) {
          for (const part of candidate.content.parts) {
              if (part.inlineData) {
                  const { mimeType, data } = part.inlineData;
                  return `data:${mimeType};base64,${data}`;
              }
          }
      }
      
      throw new Error("No image was generated by the model.");
    } catch (error) {
      console.error("Error editing image:", error);
      // Re-throw our custom safety errors, otherwise provide a generic fallback.
      if (error instanceof Error && error.message.includes('safety reasons')) {
        throw error;
      }
      throw new Error("Failed to edit the image. Please try again.");
    }
  },

  generateImage: async (prompt: string): Promise<string> => {
    try {
        const response = await ai.models.generateImages({
            model: 'imagen-4.0-generate-001',
            prompt: prompt,
            config: {
              numberOfImages: 1,
              outputMimeType: 'image/png',
              aspectRatio: '16:9',
            },
        });

        const generatedImage = response.generatedImages[0];
        if (generatedImage && generatedImage.image.imageBytes) {
            const base64ImageBytes = generatedImage.image.imageBytes;
            return `data:image/png;base64,${base64ImageBytes}`;
        }
        throw new Error("Image generation failed. The result may have been blocked for safety reasons.");
    } catch(error) {
        console.error("Error generating image:", error);
        if (error instanceof Error && error.message.includes("violated Google's Responsible AI practices")) {
             throw new Error("Image generation was blocked for safety reasons. Please try rephrasing your prompt.");
        }
        throw new Error("Failed to generate the image. Please try again.");
    }
  },

  // Fix: Add startChat and sendMessage methods to support the Chatbot component.
  startChat: (systemInstruction?: string): Chat => {
    const chatOptions: { model: string, config?: { systemInstruction: string } } = {
        model: 'gemini-2.5-flash',
    };
    if (systemInstruction) {
        chatOptions.config = {
            systemInstruction: systemInstruction
        };
    }
    return ai.chats.create(chatOptions);
  },

  sendMessage: async (chat: Chat, message: string): Promise<GenerateContentResponse> => {
    try {
      const response = await chat.sendMessage({ message });
      return response;
    } catch (error) {
        console.error("Error sending message:", error);
        throw new Error("Failed to send message. Please try again.");
    }
  },
};